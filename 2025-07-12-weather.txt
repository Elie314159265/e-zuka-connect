# 2025/07/12 天気分析機能・開発初期段階の記録

## 達成目標
- 外部APIから気象データを取得し、データベースに保存する。
- 保存したデータを読み取るためのAPIエンドポイントを実装する。

## 最終的な実装内容
- **`core-api`の機能拡張:**
    - **DBモデル:** `WeatherData`テーブルを`models.py`に定義。
    - **スキーマ:** `WeatherData`用のPydanticスキーマを`schemas.py`に定義。
    - **CRUD処理:** `weather_data`テーブルへの書き込み・読み取りを行う関数を`crud.py`に実装。
    - **APIエンドポイント:**
        - `POST /api/weather/fetch-and-store`: Open-MeteoのHistorical Weather APIから過去1週間の気象データを取得し、DBに保存する。
        - `GET /api/weather/`: DBに保存されている気象データを一覧で取得する。
- **利用API:**
    - 当初`forecast` APIを検討したが、過去のデータを取得するため`archive-api.open-meteo.com` (Historical API) を利用することになった。

---

## 開発プロセスとデバッグの記録

今回の開発は、単純な機能追加に見えて、実際にはAPIの仕様誤認やスキーマの不整合など、複数の問題が連鎖的に発生した、非常に学びの多いプロセスでした。

### 1. 初期実装と最初のAPI呼び出しエラー

- **実装内容:**
    - `routers/weather.py`を作成し、Open-Meteoの`forecast` API (`/v1/forecast`) を使って過去7日間の天気・気温・湿度を取得するロジックを実装。
- **発生した問題:**
    - `curl`でAPIエンドポイントを叩くと、`core-api`から`502 Bad Gateway`が返され、ログにはOpen-Meteo APIからの`400 Bad Request`エラーが記録された。
- **原因分析:**
    - `forecast` APIは未来の予報を取得するためのものであり、過去のデータを広範囲に取得する用途には適していなかった。特に、指定した`relativehumidity_2m_mean`というパラメータが`forecast` APIではサポートされていなかった。
- **解決策:**
    - APIを過去のデータ取得に特化した`archive-api.open-meteo.com` (`/v1/archive`) に変更。

### 2. Historical APIへの移行とパラメータの試行錯誤

- **実装内容:**
    - APIのURLを`archive-api`に変更して再デプロイ。
- **発生した問題:**
    - 再度`400 Bad Request`エラーが発生。
- **原因分析と試行錯誤の過程:**
    1.  **仮説1:** `relativehumidity_2m_mean`が`archive-api`でも無効なのではないか？
        - **試行:** パラメータを`relative_humidity_2m`に変更してデプロイ → **失敗**
    2.  **仮説2:** 湿度関連のパラメータがすべて無効なのではないか？
        - **試行:** 湿度関連のパラメータをAPIリクエストから完全に削除。ただし、レスポンス処理の部分で`humidity`を必須として扱っていたため、`core-api`内部で`500 Internal Server Error`が発生。
    3.  **仮説3:** APIリクエストとレスポンス処理の両方から、一旦湿度に関する記述を完全に削除すれば、API呼び出し自体は成功するはず。
        - **試行:** パラメータとレスポンス処理の両方から湿度関連のロジックを削除してデプロイ → **成功！** `{"message":"Successfully stored 0 new weather data entries."}`のレスポンスが得られた。

### 3. Pydanticスキーマの不整合エラー

- **実装内容:**
    - API呼び出しが成功したことを受け、DB保存ロジックのコメントアウトを解除。ただし、湿度は取得できないため、DBには`humidity=None`として保存するように修正。
- **発生した問題:**
    - `curl`で再度APIを叩くと、`500 Internal Server Error`が再発。
- **原因分析:**
    - `core-api`のログを確認したところ、`pydantic.ValidationError`が発生していた。
    - **根本原因:** `schemas.py`で定義した`WeatherDataCreate`スキーマが`humidity: float`となっており、`None`を許容していなかった。APIからデータを取得しない場合でも、DBモデルとやり取りするスキーマは`None`を受け入れられるように定義する必要があった。
- **解決策:**
    - `schemas.py`の`WeatherDataBase`スキーマを`humidity: Optional[float] = None`に修正し、`None`値を許容するように変更。
    - 再デプロイ後、`POST`リクエストが正常に成功し、DBにデータが保存されることを確認。

### 4. 最終的なGETエンドポイントの実装

- **実装内容:**
    - DBに保存されたデータを読み出すため、`crud.py`に`get_weather_data`関数を追加。
    - `weather.py`に`GET /api/weather/`エンドポイントを追加。
- **結果:**
    - デプロイ後、`curl`でGETリクエストを送信し、DBに保存された7日分の気象データがJSON形式で正常に返却されることを確認。

---

## 重要な学びと今後の改善点

- **外部APIの仕様確認は慎重に:** ドキュメントを注意深く読み、パラメータやエンドポイントの制約を正確に理解することが、手戻りを防ぐ上で最も重要。特に、同じサービスでも目的（予報/過去データ）によってエンドポイントや使えるパラメータが異なる場合がある。
- **エラーは段階的に切り分ける:** 今回のように「API呼び出し」と「DB保存」が連続する処理では、問題が発生した場合、まずAPI呼び出し単体が成功するかを分離して��ストする（今回、DB保存ロジックを一時的にコメントアウトしたアプローチ）のが有効だった。
- **スキーマ定義の重要性:** PydanticやSQLAlchemyのモデル/スキーマは、アプリケーションの堅牢性を高める一方で、`None`の扱いなど、許容する値の定義を厳密に行わないと`ValidationError`の原因となる。データが存在しない可能性のあるフィールドは、必ず`Optional`として定義する必要がある。
- **データベースマイグレーションの必要性:** 今回は開発初期段階だったため、`ALTER TABLE`を手動で実行することで解決したが、今後機能追加でDBスキーマの変更が頻発することを見越して、**Alembic**のようなマイグレーションツールを早期に導入することが強く推奨される。これにより、安全かつ体系的にスキーマ変更を管理できるようになる。
